# Enable Powerlevel10k instant prompt.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Path to your Oh My Zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Set name of the theme to load
ZSH_THEME="powerlevel10k/powerlevel10k"

# Plugins
# 注意：autosuggestions 和 syntax-highlighting 需要在 construct.yaml 中额外安装
plugins=(
  git
  sudo
  web-search
  copydir
  copyfile
  dirhistory
  zsh-autosuggestions
  zsh-syntax-highlighting
  golang
)

source $ZSH/oh-my-zsh.sh

# User configuration
export LANG=en_US.UTF-8
export EDITOR='vim'
export LIKED_CONDA_ENV='mypy' # use mypy can auto activate it and use

# Aliases
alias zshconf="vim ~/.zshrc"
alias omzconf="vim ~/.oh-my-zsh"
alias ll="ls -alh"
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias -- -='cd -'
alias myip='ip -c -br a'
alias ports='sudo ss -nultp'
alias py='python3'
alias c='batcat'
alias bat='batcat'
alias grep='rg'

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

# --- Custom Path ---
# >>> conda initialize >>>
__conda_setup="$('/home/chi/miniconda3/bin/conda' 'shell.zsh' 'hook' 2> /dev/null)"
if [ $? -eq 0 ]; then
    eval "$__conda_setup"
else
    if [ -f "/home/chi/miniconda3/etc/profile.d/conda.sh" ]; then
        . "/home/chi/miniconda3/etc/profile.d/conda.sh"
    else
        export PATH="/home/chi/miniconda3/bin:$PATH"
    fi
fi
unset __conda_setup
# <<< conda initialize <<<
alias act='conda activate'
alias dact='conda deactivate'
alias cls='conda env list'

export XMODIFIERS=@im=fcitx
export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export SDL_IM_MODULE=fcitx
export GLFW_IM_MODULE=ibus
export PATH=/opt/idea/bin:$PATH

if command -v copyfile > /dev/null 2>&1; then
    alias cpf='copyfile'
fi
if command -v copypath > /dev/null 2>&1; then
    alias cpd='copypath'
fi

mkcd() {
    mkdir -p "$1" && cd "$1"
}

mypy() {
    if [[ "$CONDA_DEFAULT_ENV" != "$LIKED_CONDA_ENV" ]]; then
        echo "Activating $LIKED_CONDA_ENV..."
        conda activate $LIKED_CONDA_ENV
    fi
    python3 "$@"
}

extract() {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xjf $1     ;;
            *.tar.gz)    tar xzf $1     ;;
            *.bz2)       bunzip2 $1     ;;
            *.rar)       unrar e $1     ;;
            *.gz)        gunzip $1      ;;
            *.tar)       tar xf $1      ;;
            *.tbz2)      tar xjf $1     ;;
            *.tgz)       tar xzf $1     ;;
            *.zip)       unzip $1       ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1        ;;
            *)           echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# ==========================================
# PM (Package Manager) Wrapper
# ==========================================
pm() {
    if [[ -z "$1" ]]; then
        echo "Usage: pm [i|s|rm|up|ug|cl] <args>"
        echo "  i   : install"
        echo "  s   : search"
        echo "  rm  : remove"
        echo "  up  : update"
        echo "  ug  : upgrade"
        return 1
    fi
    local action=$1
    shift
    local _install _search _remove _update _upgrade _clean

    if command -v apt &> /dev/null; then
        # Debian / Ubuntu
        _install="sudo apt install"
        _search="apt search"
        _remove="sudo apt remove"
        _update="sudo apt update"
        _upgrade="sudo apt upgrade"
        _clean="sudo apt autoremove && sudo apt clean"
    elif command -v dnf &> /dev/null; then
        # Fedora / RHEL 8+
        _install="sudo dnf install"
        _search="dnf search"
        _remove="sudo dnf remove"
        _update="sudo dnf check-update"
        _upgrade="sudo dnf upgrade"
        _clean="sudo dnf autoremove && sudo dnf clean all"
    elif command -v pacman &> /dev/null; then
        # Arch Linux / Manjaro
        _install="sudo pacman -S"
        _search="pacman -Ss"
        _remove="sudo pacman -Rs"
        _update="sudo pacman -Sy"
        _upgrade="sudo pacman -Syu"
        _clean="sudo pacman -Sc"
    else
        echo "Package Manager Not in (apt, dnf, pacman)"
        return 1
    fi

    case "$action" in
        i|in|install)
            ${=_install} "$@" ;;
        s|se|search)
            ${=_search} "$@" ;;
        r|rm|remove|un|uninstall)
            ${=_remove} "$@" ;;
        up|update)
            ${=_update} ;;
        ug|upgrade)
            ${=_upgrade} ;;
        cl|clean)
            eval "$_clean" ;;
        *)
            echo "Usage: pm [i|s|rm|up|ug|cl] <args>"
            echo "  i   : install"
            echo "  s   : search"
            echo "  rm  : remove"
            echo "  up  : update"
            echo "  ug  : upgrade"
            return 1
            ;;
    esac
}

# ==========================================
# Systemctl Wrapper (sc / usc)
# ==========================================
if command -v systemctl > /dev/null 2>&1; then
    _sc_build_args() {
        case "$1" in
            st)      _SC_ARGS=("status") ;;
            start|go)   _SC_ARGS=("start") ;;
            stop)    _SC_ARGS=("stop") ;;
            res)     _SC_ARGS=("restart") ;;
            rel)     _SC_ARGS=("reload") ;;
            dr)      _SC_ARGS=("daemon-reload") ;;
            en)      _SC_ARGS=("enable") ;;
            dis)     _SC_ARGS=("disable") ;;
            enn)     _SC_ARGS=("enable" "--now") ;;
            disn)    _SC_ARGS=("disable" "--now") ;;
            fail)    _SC_ARGS=("--failed") ;;
            act)     _SC_ARGS=("list-units" "--type=service" "--state=active") ;;
            *)       _SC_ARGS=("$1") ;;
        esac
    }

    sc() {
        if [ -z "$1" ]; then sudo systemctl; return; fi
        _sc_build_args "$1"; shift
        sudo systemctl "${_SC_ARGS[@]}" "$@"
    }

    usc() {
        if [ -z "$1" ]; then systemctl --user; return; fi
        _sc_build_args "$1"; shift
        systemctl --user "${_SC_ARGS[@]}" "$@"
    }
fi

# ==========================================
# Journalctl Wrapper (jlog)
# ==========================================
if command -v journalctl >/dev/null 2>&1; then
    jlog() {
        if [ -z "$1" ]; then sudo journalctl -xe; return; fi
        if [[ "$1" == -* ]]; then sudo journalctl -xe "$@"; else local svc="$1"; shift; sudo journalctl -xe -u "$svc" "$@"; fi
    }
    ujlog() {
        if [ -z "$1" ]; then journalctl --user -xe; return; fi
        if [[ "$1" == -* ]]; then journalctl --user -xe "$@"; else local svc="$1"; shift; journalctl --user -xe -u "$svc" "$@"; fi
    }
fi

# ==========================================
# Zsh Completion & Middleware
# ==========================================
autoload -Uz compinit && compinit

# 1. SC Completion
_sc_comp() {
    case "${words[2]}" in
        st)   words[2]="status" ;;
        res)  words[2]="restart" ;;
        rel)  words[2]="reload" ;;
        dr)   words[2]="daemon-reload" ;;
        en)   words[2]="enable" ;;
        dis)  words[2]="disable" ;;
        enn)  words[2]="enable" ;;
        disn) words[2]="disable" ;;
        fail) words[2]="--failed" ;;
        act)  words[2]="list-units" ;;
    esac
    if [[ "${words[1]}" == "usc" ]]; then
        words=("systemctl" "--user" "${words[@]:1}")
        (( CURRENT++ ))
    fi
    _systemctl
}
compdef _sc_comp sc usc

_pm() {
    local -a commands
    commands=(
        'i:Install package'
        's:Search package'
        'rm:Remove package'
        'up:Update repositories'
        'ug:Upgrade system'
        'cl:Clean cache'
    )

    if (( CURRENT == 2 )); then
        _describe -t commands 'pm commands' commands
        return
    fi

    local tool
    if command -v apt &> /dev/null; then tool="apt"
    elif command -v dnf &> /dev/null; then tool="dnf"
    elif command -v pacman &> /dev/null; then tool="pacman"
    else return 1; fi
    local curcontext="$curcontext" 
    local service="$tool"
    (( $+functions[_$tool] )) || autoload -U _$tool
    words[1]=$tool
    
    local sub_cmd="${words[2]}"
    case "$sub_cmd" in
        i)
            [[ "$tool" == "pacman" ]] && words[2]="-S" || words[2]="install"
            ;;
        s)
            [[ "$tool" == "pacman" ]] && words[2]="-Ss" || words[2]="search"
            ;;
        rm)
            [[ "$tool" == "pacman" ]] && words[2]="-Rs" || words[2]="remove"
            ;;
        up)
            if [[ "$tool" == "pacman" ]]; then words[2]="-Sy"; elif [[ "$tool" == "dnf" ]]; then words[2]="check-update"; else words[2]="update"; fi
            ;;
        ug)
            [[ "$tool" == "pacman" ]] && words[2]="-Syu" || words[2]="upgrade"
            ;;
        *)
            return 1
            ;;
    esac
    _$tool
}
compdef _pm pm


# ==============================================================================
# dtf (Dotfiles Wrapper) Zsh Completion
# ==============================================================================
function _dtf() {
    local context state state_descr line
    typeset -A opt_args
    local -a common_flags
    common_flags=(
        '(-n --dry-run)'{-n,--dry-run}'[Dry run mode (Simulate)]'
        '--debug[Enable debug logs]'
        '-c[Specify config file]:filename:_files'
    )

    _arguments -C \
        "${common_flags[@]}" \
        '1: :->cmds' \
        '*:: :->args'

    case $state in
        cmds)
            local -a commands
            commands=(
                "sync: Pull git changes and apply dotb"
                "apply: Apply dotb config only (no pull)"
                "edit: Edit dotfiles with default editor"
                "push:  Commit and push changes"
                "status: Show git status"
            )
            _describe -t commands 'dtf commands' commands
            ;;
        args)
            case $line[1] in
                push)
                    _message "✍️  Commit message (optional)"
                    ;;
                sync|apply)
                    _arguments \
                        "${common_flags[@]}"
                    ;;
                *)
                    ;;
            esac
            ;;
    esac
}

compdef _dtf dtf


_py_completion() {
    _files -g "*.py"
}

compdef _py_completion mypy

#THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!!
export SDKMAN_DIR="$HOME/.sdkman"
[[ -s "$HOME/.sdkman/bin/sdkman-init.sh" ]] && source "$HOME/.sdkman/bin/sdkman-init.sh"
